// /home/enzi/HXLX/plugins/mdbook-mermaid-panzoom/assets/panzoom-bundle.js
// ===== MERMAID VIEWER - WITH CACHE BUSTING =====

// Add timestamp to prevent caching
const CACHE_BUSTER = "v=" + Date.now();

// Replace all your CSS and JS references with:
// <link rel="stylesheet" href="panzoom.css?${CACHE_BUSTER}">
// <script src="panzoom-bundle.js?${CACHE_BUSTER}"></script>
class MermaidViewer {
  constructor() {
    this.viewers = new Map();
    this.initialized = false;
  }

  async init() {
    if (this.initialized) return;

    // Wait for mermaid
    await this.waitForMermaid();

    // Initialize mermaid with minimal settings
    mermaid.initialize({
      startOnLoad: false,
      theme: "dark",
      securityLevel: "loose",
    });

    // Process diagrams
    await this.processAllDiagrams();
    this.setupObserver();

    this.initialized = true;
  }

  waitForMermaid() {
    return new Promise((resolve) => {
      if (window.mermaid) return resolve();

      const check = () => {
        if (window.mermaid) resolve();
        else setTimeout(check, 100);
      };
      check();
    });
  }

  async processAllDiagrams() {
    const wrappers = document.querySelectorAll(
      ".mermaid-panzoom-wrapper:not([data-processed])",
    );

    console.log(`Found ${wrappers.length} unprocessed diagrams`);

    for (const wrapper of wrappers) {
      try {
        console.log("Processing diagram wrapper:", wrapper);
        await this.renderDiagram(wrapper);
        wrapper.dataset.processed = "true";
      } catch (error) {
        console.error("Diagram render failed:", error);
        wrapper.innerHTML = `<div class="mermaid-error">Diagram failed to render: ${error.message}</div>`;
      }
    }
  }

  async renderDiagram(wrapper) {
    const container = wrapper.querySelector(".mermaid-container");
    const codeDiv = wrapper.querySelector(".mermaid-code");

    if (!container || !codeDiv) {
      console.error("Missing container or code div");
      return;
    }

    const mermaidCode = codeDiv.textContent;
    const id = "mermaid-" + Math.random().toString(36).substr(2, 9);

    console.log(`Rendering diagram with ID: ${id}`);

    // Clear container and show loading
    container.innerHTML =
      '<div class="mermaid-loading">Loading diagram...</div>';

    try {
      // Render mermaid
      const { svg: svgString } = await mermaid.render(id, mermaidCode);

      // Clear container and add SVG
      container.innerHTML = svgString;
      const svg = container.querySelector("svg");

      if (!svg) {
        throw new Error("SVG not generated by mermaid");
      }

      console.log("Mermaid SVG generated:", {
        width: svg.getBBox().width,
        height: svg.getBBox().height,
        viewBox: svg.getAttribute("viewBox"),
      });

      // Setup pan/zoom as overlay
      this.setupPanZoomOverlay(wrapper, container, svg);
    } catch (error) {
      console.error("Diagram render failed:", error);
      container.innerHTML = `<div class="mermaid-error">Diagram failed to render: ${error.message}</div>`;
    }
  }

  setupPanZoomOverlay(wrapper, container, svg) {
    console.log("=== SETUP PANZOOM OVERLAY ===");
    console.log("Container dimensions:", container.getBoundingClientRect());
    console.log("SVG dimensions:", svg.getBBox());

    // CRITICAL: Don't modify Mermaid's SVG styling
    // Mermaid already sets width, height, viewBox - respect them!

    // State for pan/zoom
    const state = {
      scale: 1,
      translateX: 0,
      translateY: 0,
      isPanning: false,
      startX: 0,
      startY: 0,
      isFullscreen: false,
    };

    // Get SVG dimensions from viewBox or bbox
    const svgBBox = svg.getBBox();
    const svgWidth = svgBBox.width;
    const svgHeight = svgBBox.height;

    console.log("SVG actual dimensions:", { svgWidth, svgHeight });

    // Function to update transform
    const updateTransform = () => {
      console.log("Transform update:", {
        scale: state.scale,
        translateX: state.translateX,
        translateY: state.translateY,
      });

      // Apply transform to SVG
      svg.style.transform = `translate(${state.translateX}px, ${state.translateY}px) scale(${state.scale})`;
      svg.style.transformOrigin = "0 0";

      // Update zoom level display
      const zoomLevel = wrapper.querySelector(".zoom-level");
      if (zoomLevel) {
        zoomLevel.textContent = `${Math.round(state.scale * 100)}%`;
      }
    };

    // Function to fit SVG to container (only in fullscreen)
    const fitToContainer = () => {
      console.log("Fitting to container");

      if (state.isFullscreen) {
        // In fullscreen, fit to window
        const windowWidth = window.innerWidth;
        const windowHeight = window.innerHeight;

        // Calculate scale to fit with padding
        const padding = 40; // pixels
        const availableWidth = windowWidth - padding * 2;
        const availableHeight = windowHeight - padding * 2;

        const scaleX = availableWidth / svgWidth;
        const scaleY = availableHeight / svgHeight;
        const scale = Math.min(scaleX, scaleY);

        // Center the SVG
        const translateX = (windowWidth - svgWidth * scale) / 2;
        const translateY = (windowHeight - svgHeight * scale) / 2;

        state.scale = scale;
        state.translateX = translateX;
        state.translateY = translateY;
      } else {
        // Normal mode - reset to original
        state.scale = 1;
        state.translateX = 0;
        state.translateY = 0;
      }

      updateTransform();
    };

    // Fullscreen functions
    const enterFullscreen = () => {
      console.log("Entering fullscreen");

      if (state.isFullscreen) return;

      // Add fullscreen class to wrapper
      wrapper.classList.add("fullscreen-mode");

      // Store original wrapper style for restoration
      const originalStyle = {
        position: wrapper.style.position,
        top: wrapper.style.top,
        left: wrapper.style.left,
        width: wrapper.style.width,
        height: wrapper.style.height,
        zIndex: wrapper.style.zIndex,
        background: wrapper.style.background,
        margin: wrapper.style.margin,
        padding: wrapper.style.padding,
      };

      wrapper.dataset.originalStyle = JSON.stringify(originalStyle);

      // Apply fullscreen styles
      wrapper.style.position = "fixed";
      wrapper.style.top = "0";
      wrapper.style.left = "0";
      wrapper.style.width = "100vw";
      wrapper.style.height = "100vh";
      wrapper.style.zIndex = "9999";
      wrapper.style.background = "white";
      wrapper.style.margin = "0";
      wrapper.style.padding = "20px";

      state.isFullscreen = true;

      // Fit to screen
      setTimeout(() => {
        fitToContainer();
      }, 50);
    };

    const exitFullscreen = () => {
      console.log("Exiting fullscreen");

      if (!state.isFullscreen) return;

      // Remove fullscreen class
      wrapper.classList.remove("fullscreen-mode");

      // Restore original styles
      try {
        const originalStyle = JSON.parse(wrapper.dataset.originalStyle || "{}");
        Object.entries(originalStyle).forEach(([prop, value]) => {
          wrapper.style[prop] = value || "";
        });
      } catch (e) {
        // If restoration fails, just reset
        wrapper.style.cssText = "";
      }

      // Remove stored style
      delete wrapper.dataset.originalStyle;

      state.isFullscreen = false;

      // Reset transform
      state.scale = 1;
      state.translateX = 0;
      state.translateY = 0;

      updateTransform();
    };

    // ===== EVENT HANDLERS =====

    // Mouse down for panning
    const handleMouseDown = (e) => {
      if (e.button !== 0) return; // Left click only

      console.log("Mouse down for panning");

      state.isPanning = true;
      state.startX = e.clientX - state.translateX;
      state.startY = e.clientY - state.translateY;

      // Change cursor
      svg.style.cursor = "grabbing";
      e.preventDefault();
    };

    // Mouse move for panning
    const handleMouseMove = (e) => {
      if (!state.isPanning) return;

      state.translateX = e.clientX - state.startX;
      state.translateY = e.clientY - state.startY;

      updateTransform();
    };

    // Mouse up/leave to stop panning
    const handleMouseUp = () => {
      if (!state.isPanning) return;

      console.log("Mouse up - stop panning");

      state.isPanning = false;
      svg.style.cursor = "grab";
    };

    // Wheel for zooming
    const handleWheel = (e) => {
      e.preventDefault();

      // Get mouse position relative to container
      const rect = container.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;

      // Calculate zoom
      const oldScale = state.scale;
      const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
      state.scale *= zoomFactor;

      // Clamp scale
      state.scale = Math.max(0.1, Math.min(20, state.scale));

      // Adjust position to zoom toward mouse
      const scaleRatio = state.scale / oldScale;
      state.translateX = mouseX - (mouseX - state.translateX) * scaleRatio;
      state.translateY = mouseY - (mouseY - state.translateY) * scaleRatio;

      updateTransform();
    };

    // ===== SETUP EVENT LISTENERS =====

    // Add event listeners to SVG (not container!)
    svg.addEventListener("mousedown", handleMouseDown);
    svg.addEventListener("mousemove", handleMouseMove);
    svg.addEventListener("mouseup", handleMouseUp);
    svg.addEventListener("mouseleave", handleMouseUp);
    svg.addEventListener("wheel", handleWheel, { passive: false });

    // Set initial cursor
    svg.style.cursor = "grab";

    // ===== SETUP CONTROL BUTTONS =====

    const controls = wrapper.querySelector(".mermaid-panzoom-controls");
    if (controls) {
      console.log("Setting up control buttons");

      // Zoom in
      controls.querySelector(".zoom-in")?.addEventListener("click", () => {
        state.scale *= 1.2;
        state.scale = Math.min(20, state.scale);
        updateTransform();
      });

      // Zoom out
      controls.querySelector(".zoom-out")?.addEventListener("click", () => {
        state.scale /= 1.2;
        state.scale = Math.max(0.1, state.scale);
        updateTransform();
      });

      // Reset view
      controls.querySelector(".reset-view")?.addEventListener("click", () => {
        state.scale = 1;
        state.translateX = 0;
        state.translateY = 0;
        updateTransform();
      });

      // Fit/Fullscreen toggle
      const fitButton = controls.querySelector(".fit-view");
      if (fitButton) {
        fitButton.addEventListener("click", () => {
          if (state.isFullscreen) {
            exitFullscreen();
            fitButton.textContent = "⤢";
            fitButton.title = "Fit to view (full screen)";
          } else {
            enterFullscreen();
            fitButton.textContent = "✕";
            fitButton.title = "Exit full screen";
          }
        });
      }
    }

    // Handle Escape key for fullscreen exit
    const handleEscape = (e) => {
      if (e.key === "Escape" && state.isFullscreen) {
        exitFullscreen();
        const fitButton = wrapper.querySelector(".fit-view");
        if (fitButton) {
          fitButton.textContent = "⤢";
          fitButton.title = "Fit to view (full screen)";
        }
      }
    };

    document.addEventListener("keydown", handleEscape);

    // Handle window resize for fullscreen
    const handleResize = () => {
      if (state.isFullscreen) {
        fitToContainer();
      }
    };

    window.addEventListener("resize", handleResize);

    // Store cleanup function
    const cleanup = () => {
      svg.removeEventListener("mousedown", handleMouseDown);
      svg.removeEventListener("mousemove", handleMouseMove);
      svg.removeEventListener("mouseup", handleMouseUp);
      svg.removeEventListener("mouseleave", handleMouseUp);
      svg.removeEventListener("wheel", handleWheel);
      document.removeEventListener("keydown", handleEscape);
      window.removeEventListener("resize", handleResize);

      // Clean up control events
      if (controls) {
        controls.querySelector(".zoom-in")?.removeEventListener("click");
        controls.querySelector(".zoom-out")?.removeEventListener("click");
        controls.querySelector(".reset-view")?.removeEventListener("click");
        controls.querySelector(".fit-view")?.removeEventListener("click");
      }
    };

    // Store viewer for later cleanup
    this.viewers.set(wrapper, { cleanup });

    console.log("=== PANZOOM OVERLAY SETUP COMPLETE ===");

    // Initial log of final state
    setTimeout(() => {
      console.log("Final state:", {
        containerRect: container.getBoundingClientRect(),
        svgRect: svg.getBoundingClientRect(),
        svgBBox: svg.getBBox(),
        transform: svg.style.transform,
      });
    }, 100);
  }

  setupObserver() {
    const observer = new MutationObserver((mutations) => {
      for (const mutation of mutations) {
        if (mutation.type === "childList") {
          this.processAllDiagrams().catch(console.error);
        }
      }
    });

    observer.observe(document.body, {
      childList: true,
      subtree: true,
    });
  }
}

// Auto-initialize
document.addEventListener("DOMContentLoaded", () => {
  console.log("Mermaid PanZoom initializing...");
  window.mermaidViewer = new MermaidViewer();
  window.mermaidViewer.init().catch((err) => {
    console.warn("Mermaid viewer initialization failed:", err);
  });
});
